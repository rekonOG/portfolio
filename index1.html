<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Game</title>
    <link rel="stylesheet" href="style1.css">
</head>
<body>
    <div id="three-bg"></div>
    <h1 id="game-title">Black Hole Game</h1>

    <div id="setup-menu" class="controls">
        <h2>Game Setup</h2>
        <div class="menu-option">
            <label for="player-count">Players</label>
            <select id="player-count">
                <option value="2">2 Players</option>
                <option value="3">3 Players</option>
            </select>
        </div>
        <div class="menu-option">
            <label>Game Mode</label>
            <div class="mode-switch">
                <label class="switch">
                    <input type="checkbox" id="mode-toggle" onchange="toggleMode()">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        <button id="start-button" onclick="startGame()">Start Game</button>
    </div>


    <div id="game-area" class="hidden">
        <div id="status"></div>
        <div id="game-board"></div>
        <div id="score-area"></div>
    </div>

    <button id="show-menu-button" class="hidden" onclick="returnToMenu()">Show Menu</button>

    <script src="script1.js"></script>
    <script type="module">
        import {
            Scene, WebGLRenderer, PerspectiveCamera, 
            InstancedMesh, InstancedBufferAttribute,
            CylinderBufferGeometry, MeshBasicMaterial, CanvasTexture, BackSide
        } from 'https://unpkg.com/three@0.121.1/build/three.module.js';
        
        const time = {value: 0};
        
        // Mount renderer to #three-bg
        const bgDiv = document.getElementById('three-bg');
        const renderer = new WebGLRenderer({ antialias: true });
        renderer.setClearColor(0x000000, 1);
        bgDiv.appendChild(renderer.domElement);

        const scene = new Scene();
        const camera = new PerspectiveCamera();
        camera.position.set(3,3,3);
        camera.lookAt(0,0.7,0);

        const geom = new CylinderBufferGeometry(1, 1, 1, 64, 64, true);
        const mat = new MeshBasicMaterial({ wireframe: true });

        const vertexCode = `
            float y = mvPosition.y+0.5;
            mvPosition.xz *= 0.1+pow(y, 10.+sin(time/3.)*7.)*20.;
            mvPosition.y *= 5.;
        `;
        scene.add( createInstancedMesh(1, geom, mat, vertexCode) );

        function resizeRenderer() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            renderer.setSize(w, h);
            camera.aspect = w/h;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', resizeRenderer);
        resizeRenderer();

        requestAnimationFrame(function render(t) {
            time.value = t/1000;
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        });

        function gridTexture() {
            const canvas = document.createElement('canvas');
            const s = canvas.height = canvas.width = 4096;
            const ctx = canvas.getContext('2d');
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 10;
            for (let i=0;i<20;i++) {
                for (var j=0;j<2;j++) {
                    ctx.beginPath();
                    ctx.moveTo(i*s/10-s, j?0:s)
                    ctx.lineTo(i*s/10,   j?s:0)
                    ctx.stroke();    
                }
            }
            const map = new CanvasTexture(canvas);
            map.anisotropy = 8;
            return map;
        }

        function createInstancedMesh(instanceCount, geometry, material, vertesShaderPart){
            let indexes = [...Array(instanceCount)].map((_,i) => i);
            indexes = new Float32Array(indexes);
            indexes = new InstancedBufferAttribute(indexes, 1);
            geometry.setAttribute( 'index',  indexes);

            material.onBeforeCompile = (shader) => {
                shader.uniforms.time = time;
                shader.vertexShader = shader.vertexShader
                    .split('#include <common>').join(`
            uniform float time;
            attribute float index;
            #include <common>
                    `)
                    .split('#include <project_vertex>').join(`
            vec4 mvPosition = vec4( transformed, 1.0 );
            ${vertesShaderPart}
            mvPosition = modelViewMatrix * mvPosition;
            gl_Position = projectionMatrix * mvPosition;
                    `);
            }
            return new InstancedMesh( geometry, material, instanceCount )
        }
    </script>
</body>
</html>
